import { parseConnectionUri } from "../utils/utils.ts";
import { ConnectionParamsError } from "../client/error.ts";
import { fromFileUrl, isAbsolute } from "../deps.ts";
/**
 * This function retrieves the connection options from the environmental variables
 * as they are, without any extra parsing
 *
 * It will throw if no env permission was provided on startup
 */ function getPgEnv() {
    return {
        applicationName: Deno.env.get("PGAPPNAME"),
        database: Deno.env.get("PGDATABASE"),
        hostname: Deno.env.get("PGHOST"),
        options: Deno.env.get("PGOPTIONS"),
        password: Deno.env.get("PGPASSWORD"),
        port: Deno.env.get("PGPORT"),
        user: Deno.env.get("PGUSER")
    };
}
function formatMissingParams(missingParams) {
    return `Missing connection parameters: ${missingParams.join(", ")}`;
}
/**
 * This validates the options passed are defined and have a value other than null
 * or empty string, it throws a connection error otherwise
 *
 * @param has_env_access This parameter will change the error message if set to true,
 * telling the user to pass env permissions in order to read environmental variables
 */ function assertRequiredOptions(options, requiredKeys, has_env_access) {
    const missingParams = [];
    for (const key of requiredKeys){
        if (options[key] === "" || options[key] === null || options[key] === undefined) {
            missingParams.push(key);
        }
    }
    if (missingParams.length) {
        let missing_params_message = formatMissingParams(missingParams);
        if (!has_env_access) {
            missing_params_message += "\nConnection parameters can be read from environment variables only if Deno is run with env permission";
        }
        throw new ConnectionParamsError(missing_params_message);
    }
}
function parseOptionsArgument(options) {
    const args = options.split(" ");
    const transformed_args = [];
    for(let x = 0; x < args.length; x++){
        if (/^-\w/.test(args[x])) {
            if (args[x] === "-c") {
                if (args[x + 1] === undefined) {
                    throw new Error(`No provided value for "${args[x]}" in options parameter`);
                }
                // Skip next iteration
                transformed_args.push(args[x + 1]);
                x++;
            } else {
                throw new Error(`Argument "${args[x]}" is not supported in options parameter`);
            }
        } else if (/^--\w/.test(args[x])) {
            transformed_args.push(args[x].slice(2));
        } else {
            throw new Error(`Value "${args[x]}" is not a valid options argument`);
        }
    }
    return transformed_args.reduce((options, x)=>{
        if (!/.+=.+/.test(x)) {
            throw new Error(`Value "${x}" is not a valid options argument`);
        }
        const key = x.slice(0, x.indexOf("="));
        const value = x.slice(x.indexOf("=") + 1);
        options[key] = value;
        return options;
    }, {});
}
function parseOptionsFromUri(connection_string) {
    let postgres_uri;
    try {
        const uri = parseConnectionUri(connection_string);
        postgres_uri = {
            application_name: uri.params.application_name,
            dbname: uri.path || uri.params.dbname,
            driver: uri.driver,
            host: uri.host || uri.params.host,
            options: uri.params.options,
            password: uri.password || uri.params.password,
            port: uri.port || uri.params.port,
            // Compatibility with JDBC, not standard
            // Treat as sslmode=require
            sslmode: uri.params.ssl === "true" ? "require" : uri.params.sslmode,
            user: uri.user || uri.params.user
        };
    } catch (e) {
        throw new ConnectionParamsError(`Could not parse the connection string`, e);
    }
    if (![
        "postgres",
        "postgresql"
    ].includes(postgres_uri.driver)) {
        throw new ConnectionParamsError(`Supplied DSN has invalid driver: ${postgres_uri.driver}.`);
    }
    // No host by default means socket connection
    const host_type = postgres_uri.host ? isAbsolute(postgres_uri.host) ? "socket" : "tcp" : "socket";
    const options = postgres_uri.options ? parseOptionsArgument(postgres_uri.options) : {};
    let tls;
    switch(postgres_uri.sslmode){
        case undefined:
            {
                break;
            }
        case "disable":
            {
                tls = {
                    enabled: false,
                    enforce: false,
                    caCertificates: []
                };
                break;
            }
        case "prefer":
            {
                tls = {
                    enabled: true,
                    enforce: false,
                    caCertificates: []
                };
                break;
            }
        case "require":
        case "verify-ca":
        case "verify-full":
            {
                tls = {
                    enabled: true,
                    enforce: true,
                    caCertificates: []
                };
                break;
            }
        default:
            {
                throw new ConnectionParamsError(`Supplied DSN has invalid sslmode '${postgres_uri.sslmode}'`);
            }
    }
    return {
        applicationName: postgres_uri.application_name,
        database: postgres_uri.dbname,
        hostname: postgres_uri.host,
        host_type,
        options,
        password: postgres_uri.password,
        port: postgres_uri.port,
        tls,
        user: postgres_uri.user
    };
}
const DEFAULT_OPTIONS = {
    applicationName: "deno_postgres",
    connection: {
        attempts: 1,
        interval: (previous_interval)=>previous_interval + 500
    },
    host: "127.0.0.1",
    socket: "/tmp",
    host_type: "socket",
    options: {},
    port: 5432,
    tls: {
        enabled: true,
        enforce: false,
        caCertificates: []
    }
};
export function createParams(params = {}) {
    if (typeof params === "string") {
        params = parseOptionsFromUri(params);
    }
    let pgEnv = {};
    let has_env_access = true;
    try {
        pgEnv = getPgEnv();
    } catch (e) {
        if (e instanceof Deno.errors.PermissionDenied) {
            has_env_access = false;
        } else {
            throw e;
        }
    }
    const provided_host = params.hostname ?? pgEnv.hostname;
    // If a host is provided, the default connection type is TCP
    const host_type = params.host_type ?? (provided_host ? "tcp" : DEFAULT_OPTIONS.host_type);
    if (![
        "tcp",
        "socket"
    ].includes(host_type)) {
        throw new ConnectionParamsError(`"${host_type}" is not a valid host type`);
    }
    let host;
    if (host_type === "socket") {
        const socket = provided_host ?? DEFAULT_OPTIONS.socket;
        try {
            if (!isAbsolute(socket)) {
                const parsed_host = new URL(socket, Deno.mainModule);
                // Resolve relative path
                if (parsed_host.protocol === "file:") {
                    host = fromFileUrl(parsed_host);
                } else {
                    throw new Error("The provided host is not a file path");
                }
            } else {
                host = socket;
            }
        } catch (e1) {
            throw new ConnectionParamsError(`Could not parse host "${socket}"`, e1);
        }
    } else {
        host = provided_host ?? DEFAULT_OPTIONS.host;
    }
    const provided_options = params.options ?? pgEnv.options;
    let options;
    if (provided_options) {
        if (typeof provided_options === "string") {
            options = parseOptionsArgument(provided_options);
        } else {
            options = provided_options;
        }
    } else {
        options = {};
    }
    for(const key in options){
        if (!/^\w+$/.test(key)) {
            throw new Error(`The "${key}" key in the options argument is invalid`);
        }
        options[key] = options[key].replaceAll(" ", "\\ ");
    }
    let port;
    if (params.port) {
        port = Number(params.port);
    } else if (pgEnv.port) {
        port = Number(pgEnv.port);
    } else {
        port = DEFAULT_OPTIONS.port;
    }
    if (Number.isNaN(port) || port === 0) {
        throw new ConnectionParamsError(`"${params.port ?? pgEnv.port}" is not a valid port number`);
    }
    if (host_type === "socket" && params?.tls) {
        throw new ConnectionParamsError(`No TLS options are allowed when host type is set to "socket"`);
    }
    const tls_enabled = !!(params?.tls?.enabled ?? DEFAULT_OPTIONS.tls.enabled);
    const tls_enforced = !!(params?.tls?.enforce ?? DEFAULT_OPTIONS.tls.enforce);
    if (!tls_enabled && tls_enforced) {
        throw new ConnectionParamsError("Can't enforce TLS when client has TLS encryption is disabled");
    }
    // TODO
    // Perhaps username should be taken from the PC user as a default?
    const connection_options = {
        applicationName: params.applicationName ?? pgEnv.applicationName ?? DEFAULT_OPTIONS.applicationName,
        connection: {
            attempts: params?.connection?.attempts ?? DEFAULT_OPTIONS.connection.attempts,
            interval: params?.connection?.interval ?? DEFAULT_OPTIONS.connection.interval
        },
        database: params.database ?? pgEnv.database,
        hostname: host,
        host_type,
        options,
        password: params.password ?? pgEnv.password,
        port,
        tls: {
            enabled: tls_enabled,
            enforce: tls_enforced,
            caCertificates: params?.tls?.caCertificates ?? []
        },
        user: params.user ?? pgEnv.user
    };
    assertRequiredOptions(connection_options, [
        "applicationName",
        "database",
        "hostname",
        "host_type",
        "port",
        "user"
    ], has_env_access);
    return connection_options;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvcG9zdGdyZXNAdjAuMTcuMC9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fcGFyYW1zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlQ29ubmVjdGlvblVyaSB9IGZyb20gXCIuLi91dGlscy91dGlscy50c1wiO1xuaW1wb3J0IHsgQ29ubmVjdGlvblBhcmFtc0Vycm9yIH0gZnJvbSBcIi4uL2NsaWVudC9lcnJvci50c1wiO1xuaW1wb3J0IHsgZnJvbUZpbGVVcmwsIGlzQWJzb2x1dGUgfSBmcm9tIFwiLi4vZGVwcy50c1wiO1xuXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIHN0cmluZyBtdXN0IG1hdGNoIHRoZSBmb2xsb3dpbmcgVVJJIHN0cnVjdHVyZS4gQWxsIHBhcmFtZXRlcnMgYnV0IGRhdGFiYXNlIGFuZCB1c2VyIGFyZSBvcHRpb25hbFxuICpcbiAqIGBwb3N0Z3JlczovL3VzZXI6cGFzc3dvcmRAaG9zdG5hbWU6cG9ydC9kYXRhYmFzZT9zc2xtb2RlPW1vZGUuLi5gXG4gKlxuICogWW91IGNhbiBhZGRpdGlvbmFsbHkgcHJvdmlkZSB0aGUgZm9sbG93aW5nIHVybCBzZWFyY2ggcGFyYW1ldGVyc1xuICpcbiAqIC0gYXBwbGljYXRpb25fbmFtZVxuICogLSBkYm5hbWVcbiAqIC0gaG9zdFxuICogLSBvcHRpb25zXG4gKiAtIHBhc3N3b3JkXG4gKiAtIHBvcnRcbiAqIC0gc3NsbW9kZVxuICogLSB1c2VyXG4gKi9cbmV4cG9ydCB0eXBlIENvbm5lY3Rpb25TdHJpbmcgPSBzdHJpbmc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXRyaWV2ZXMgdGhlIGNvbm5lY3Rpb24gb3B0aW9ucyBmcm9tIHRoZSBlbnZpcm9ubWVudGFsIHZhcmlhYmxlc1xuICogYXMgdGhleSBhcmUsIHdpdGhvdXQgYW55IGV4dHJhIHBhcnNpbmdcbiAqXG4gKiBJdCB3aWxsIHRocm93IGlmIG5vIGVudiBwZXJtaXNzaW9uIHdhcyBwcm92aWRlZCBvbiBzdGFydHVwXG4gKi9cbmZ1bmN0aW9uIGdldFBnRW52KCk6IENsaWVudE9wdGlvbnMge1xuICByZXR1cm4ge1xuICAgIGFwcGxpY2F0aW9uTmFtZTogRGVuby5lbnYuZ2V0KFwiUEdBUFBOQU1FXCIpLFxuICAgIGRhdGFiYXNlOiBEZW5vLmVudi5nZXQoXCJQR0RBVEFCQVNFXCIpLFxuICAgIGhvc3RuYW1lOiBEZW5vLmVudi5nZXQoXCJQR0hPU1RcIiksXG4gICAgb3B0aW9uczogRGVuby5lbnYuZ2V0KFwiUEdPUFRJT05TXCIpLFxuICAgIHBhc3N3b3JkOiBEZW5vLmVudi5nZXQoXCJQR1BBU1NXT1JEXCIpLFxuICAgIHBvcnQ6IERlbm8uZW52LmdldChcIlBHUE9SVFwiKSxcbiAgICB1c2VyOiBEZW5vLmVudi5nZXQoXCJQR1VTRVJcIiksXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogQnkgZGVmYXVsdCwgYW55IGNsaWVudCB3aWxsIG9ubHkgYXR0ZW1wdCB0byBzdGFibGlzaFxuICAgKiBjb25uZWN0aW9uIHdpdGggeW91ciBkYXRhYmFzZSBvbmNlLiBTZXR0aW5nIHRoaXMgcGFyYW1ldGVyXG4gICAqIHdpbGwgY2F1c2UgdGhlIGNsaWVudCB0byBhdHRlbXB0IHJlY29ubmVjdGlvbiBhcyBtYW55IHRpbWVzXG4gICAqIGFzIHJlcXVlc3RlZCBiZWZvcmUgZXJyb3JpbmdcbiAgICpcbiAgICogZGVmYXVsdDogYDFgXG4gICAqL1xuICBhdHRlbXB0czogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHRpbWUgdG8gd2FpdCBiZWZvcmUgYXR0ZW1wdGluZyBlYWNoIHJlY29ubmVjdGlvbiAoaW4gbWlsbGlzZWNvbmRzKVxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBmaXhlZCBudW1iZXIgb3IgYSBmdW5jdGlvbiB0byBjYWxsIGVhY2ggdGltZSB0aGVcbiAgICogY29ubmVjdGlvbiBpcyBhdHRlbXB0ZWQuIEJ5IGRlZmF1bHQsIHRoZSBpbnRlcnZhbCB3aWxsIGJlIGEgZnVuY3Rpb25cbiAgICogd2l0aCBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIGluY3JlYXNpbmcgYnkgNTAwIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgaW50ZXJ2YWw6IG51bWJlciB8ICgocHJldmlvdXNfaW50ZXJ2YWw6IG51bWJlcikgPT4gbnVtYmVyKTtcbn1cblxuLyoqIGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvMTQvbGlicHEtc3NsLmh0bWwjTElCUFEtU1NMLVBST1RFQ1RJT04gKi9cbnR5cGUgVExTTW9kZXMgPVxuICB8IFwiZGlzYWJsZVwiXG4gIHwgXCJwcmVmZXJcIlxuICB8IFwicmVxdWlyZVwiXG4gIHwgXCJ2ZXJpZnktY2FcIlxuICB8IFwidmVyaWZ5LWZ1bGxcIjtcblxuLy8gVE9ET1xuLy8gUmVmYWN0b3IgZW5hYmxlZCBhbmQgZW5mb3JjZSBpbnRvIG9uZSBzaW5nbGUgb3B0aW9uIGZvciAxLjBcbmV4cG9ydCBpbnRlcmZhY2UgVExTT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZiBUTFMgc3VwcG9ydCBpcyBlbmFibGVkIG9yIG5vdC4gSWYgdGhlIHNlcnZlciByZXF1aXJlcyBUTFMsXG4gICAqIHRoZSBjb25uZWN0aW9uIHdpbGwgZmFpbC5cbiAgICpcbiAgICogRGVmYXVsdDogYHRydWVgXG4gICAqL1xuICBlbmFibGVkOiBib29sZWFuO1xuICAvKipcbiAgICogVGhpcyB3aWxsIGZvcmNlIHRoZSBjb25uZWN0aW9uIHRvIHJ1biBvdmVyIFRMU1xuICAgKiBJZiB0aGUgc2VydmVyIGRvZXNuJ3Qgc3VwcG9ydCBUTFMsIHRoZSBjb25uZWN0aW9uIHdpbGwgZmFpbFxuICAgKlxuICAgKiBEZWZhdWx0OiBgZmFsc2VgXG4gICAqL1xuICBlbmZvcmNlOiBib29sZWFuO1xuICAvKipcbiAgICogQSBsaXN0IG9mIHJvb3QgY2VydGlmaWNhdGVzIHRoYXQgd2lsbCBiZSB1c2VkIGluIGFkZGl0aW9uIHRvIHRoZSBkZWZhdWx0XG4gICAqIHJvb3QgY2VydGlmaWNhdGVzIHRvIHZlcmlmeSB0aGUgc2VydmVyJ3MgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIE11c3QgYmUgaW4gUEVNIGZvcm1hdC5cbiAgICpcbiAgICogRGVmYXVsdDogYFtdYFxuICAgKi9cbiAgY2FDZXJ0aWZpY2F0ZXM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudE9wdGlvbnMge1xuICBhcHBsaWNhdGlvbk5hbWU/OiBzdHJpbmc7XG4gIGNvbm5lY3Rpb24/OiBQYXJ0aWFsPENvbm5lY3Rpb25PcHRpb25zPjtcbiAgZGF0YWJhc2U/OiBzdHJpbmc7XG4gIGhvc3RuYW1lPzogc3RyaW5nO1xuICBob3N0X3R5cGU/OiBcInRjcFwiIHwgXCJzb2NrZXRcIjtcbiAgb3B0aW9ucz86IHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHBhc3N3b3JkPzogc3RyaW5nO1xuICBwb3J0Pzogc3RyaW5nIHwgbnVtYmVyO1xuICB0bHM/OiBQYXJ0aWFsPFRMU09wdGlvbnM+O1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudENvbmZpZ3VyYXRpb24ge1xuICBhcHBsaWNhdGlvbk5hbWU6IHN0cmluZztcbiAgY29ubmVjdGlvbjogQ29ubmVjdGlvbk9wdGlvbnM7XG4gIGRhdGFiYXNlOiBzdHJpbmc7XG4gIGhvc3RuYW1lOiBzdHJpbmc7XG4gIGhvc3RfdHlwZTogXCJ0Y3BcIiB8IFwic29ja2V0XCI7XG4gIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHBhc3N3b3JkPzogc3RyaW5nO1xuICBwb3J0OiBudW1iZXI7XG4gIHRsczogVExTT3B0aW9ucztcbiAgdXNlcjogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNaXNzaW5nUGFyYW1zKG1pc3NpbmdQYXJhbXM6IHN0cmluZ1tdKSB7XG4gIHJldHVybiBgTWlzc2luZyBjb25uZWN0aW9uIHBhcmFtZXRlcnM6ICR7XG4gICAgbWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgXCIsIFwiLFxuICAgIClcbiAgfWA7XG59XG5cbi8qKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhlIG9wdGlvbnMgcGFzc2VkIGFyZSBkZWZpbmVkIGFuZCBoYXZlIGEgdmFsdWUgb3RoZXIgdGhhbiBudWxsXG4gKiBvciBlbXB0eSBzdHJpbmcsIGl0IHRocm93cyBhIGNvbm5lY3Rpb24gZXJyb3Igb3RoZXJ3aXNlXG4gKlxuICogQHBhcmFtIGhhc19lbnZfYWNjZXNzIFRoaXMgcGFyYW1ldGVyIHdpbGwgY2hhbmdlIHRoZSBlcnJvciBtZXNzYWdlIGlmIHNldCB0byB0cnVlLFxuICogdGVsbGluZyB0aGUgdXNlciB0byBwYXNzIGVudiBwZXJtaXNzaW9ucyBpbiBvcmRlciB0byByZWFkIGVudmlyb25tZW50YWwgdmFyaWFibGVzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkT3B0aW9ucyhcbiAgb3B0aW9uczogUGFydGlhbDxDbGllbnRDb25maWd1cmF0aW9uPixcbiAgcmVxdWlyZWRLZXlzOiAoa2V5b2YgQ2xpZW50T3B0aW9ucylbXSxcbiAgaGFzX2Vudl9hY2Nlc3M6IGJvb2xlYW4sXG4pOiBhc3NlcnRzIG9wdGlvbnMgaXMgQ2xpZW50Q29uZmlndXJhdGlvbiB7XG4gIGNvbnN0IG1pc3NpbmdQYXJhbXM6IChrZXlvZiBDbGllbnRPcHRpb25zKVtdID0gW107XG4gIGZvciAoY29uc3Qga2V5IG9mIHJlcXVpcmVkS2V5cykge1xuICAgIGlmIChcbiAgICAgIG9wdGlvbnNba2V5XSA9PT0gXCJcIiB8fFxuICAgICAgb3B0aW9uc1trZXldID09PSBudWxsIHx8XG4gICAgICBvcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgbWlzc2luZ1BhcmFtcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoKSB7XG4gICAgbGV0IG1pc3NpbmdfcGFyYW1zX21lc3NhZ2UgPSBmb3JtYXRNaXNzaW5nUGFyYW1zKG1pc3NpbmdQYXJhbXMpO1xuICAgIGlmICghaGFzX2Vudl9hY2Nlc3MpIHtcbiAgICAgIG1pc3NpbmdfcGFyYW1zX21lc3NhZ2UgKz1cbiAgICAgICAgXCJcXG5Db25uZWN0aW9uIHBhcmFtZXRlcnMgY2FuIGJlIHJlYWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb25seSBpZiBEZW5vIGlzIHJ1biB3aXRoIGVudiBwZXJtaXNzaW9uXCI7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IENvbm5lY3Rpb25QYXJhbXNFcnJvcihtaXNzaW5nX3BhcmFtc19tZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBUT0RPXG4vLyBTdXBwb3J0IG1vcmUgb3B0aW9ucyBmcm9tIHRoZSBzcGVjXG4vKiogb3B0aW9ucyBmcm9tIFVSSSBwZXIgaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy8xNC9saWJwcS1jb25uZWN0Lmh0bWwjTElCUFEtQ09OTlNUUklORyAqL1xuaW50ZXJmYWNlIFBvc3RncmVzVXJpIHtcbiAgYXBwbGljYXRpb25fbmFtZT86IHN0cmluZztcbiAgZGJuYW1lPzogc3RyaW5nO1xuICBkcml2ZXI6IHN0cmluZztcbiAgaG9zdD86IHN0cmluZztcbiAgb3B0aW9ucz86IHN0cmluZztcbiAgcGFzc3dvcmQ/OiBzdHJpbmc7XG4gIHBvcnQ/OiBzdHJpbmc7XG4gIHNzbG1vZGU/OiBUTFNNb2RlcztcbiAgdXNlcj86IHN0cmluZztcbn1cblxuZnVuY3Rpb24gcGFyc2VPcHRpb25zQXJndW1lbnQob3B0aW9uczogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIGNvbnN0IGFyZ3MgPSBvcHRpb25zLnNwbGl0KFwiIFwiKTtcblxuICBjb25zdCB0cmFuc2Zvcm1lZF9hcmdzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgYXJncy5sZW5ndGg7IHgrKykge1xuICAgIGlmICgvXi1cXHcvLnRlc3QoYXJnc1t4XSkpIHtcbiAgICAgIGlmIChhcmdzW3hdID09PSBcIi1jXCIpIHtcbiAgICAgICAgaWYgKGFyZ3NbeCArIDFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm8gcHJvdmlkZWQgdmFsdWUgZm9yIFwiJHthcmdzW3hdfVwiIGluIG9wdGlvbnMgcGFyYW1ldGVyYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBuZXh0IGl0ZXJhdGlvblxuICAgICAgICB0cmFuc2Zvcm1lZF9hcmdzLnB1c2goYXJnc1t4ICsgMV0pO1xuICAgICAgICB4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEFyZ3VtZW50IFwiJHthcmdzW3hdfVwiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gb3B0aW9ucyBwYXJhbWV0ZXJgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL14tLVxcdy8udGVzdChhcmdzW3hdKSkge1xuICAgICAgdHJhbnNmb3JtZWRfYXJncy5wdXNoKGFyZ3NbeF0uc2xpY2UoMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBWYWx1ZSBcIiR7YXJnc1t4XX1cIiBpcyBub3QgYSB2YWxpZCBvcHRpb25zIGFyZ3VtZW50YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybWVkX2FyZ3MucmVkdWNlKChvcHRpb25zLCB4KSA9PiB7XG4gICAgaWYgKCEvLis9LisvLnRlc3QoeCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgXCIke3h9XCIgaXMgbm90IGEgdmFsaWQgb3B0aW9ucyBhcmd1bWVudGApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHguc2xpY2UoMCwgeC5pbmRleE9mKFwiPVwiKSk7XG4gICAgY29uc3QgdmFsdWUgPSB4LnNsaWNlKHguaW5kZXhPZihcIj1cIikgKyAxKTtcblxuICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnNGcm9tVXJpKGNvbm5lY3Rpb25fc3RyaW5nOiBzdHJpbmcpOiBDbGllbnRPcHRpb25zIHtcbiAgbGV0IHBvc3RncmVzX3VyaTogUG9zdGdyZXNVcmk7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJpID0gcGFyc2VDb25uZWN0aW9uVXJpKGNvbm5lY3Rpb25fc3RyaW5nKTtcbiAgICBwb3N0Z3Jlc191cmkgPSB7XG4gICAgICBhcHBsaWNhdGlvbl9uYW1lOiB1cmkucGFyYW1zLmFwcGxpY2F0aW9uX25hbWUsXG4gICAgICBkYm5hbWU6IHVyaS5wYXRoIHx8IHVyaS5wYXJhbXMuZGJuYW1lLFxuICAgICAgZHJpdmVyOiB1cmkuZHJpdmVyLFxuICAgICAgaG9zdDogdXJpLmhvc3QgfHwgdXJpLnBhcmFtcy5ob3N0LFxuICAgICAgb3B0aW9uczogdXJpLnBhcmFtcy5vcHRpb25zLFxuICAgICAgcGFzc3dvcmQ6IHVyaS5wYXNzd29yZCB8fCB1cmkucGFyYW1zLnBhc3N3b3JkLFxuICAgICAgcG9ydDogdXJpLnBvcnQgfHwgdXJpLnBhcmFtcy5wb3J0LFxuICAgICAgLy8gQ29tcGF0aWJpbGl0eSB3aXRoIEpEQkMsIG5vdCBzdGFuZGFyZFxuICAgICAgLy8gVHJlYXQgYXMgc3NsbW9kZT1yZXF1aXJlXG4gICAgICBzc2xtb2RlOiB1cmkucGFyYW1zLnNzbCA9PT0gXCJ0cnVlXCJcbiAgICAgICAgPyBcInJlcXVpcmVcIlxuICAgICAgICA6IHVyaS5wYXJhbXMuc3NsbW9kZSBhcyBUTFNNb2RlcyxcbiAgICAgIHVzZXI6IHVyaS51c2VyIHx8IHVyaS5wYXJhbXMudXNlcixcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IENvbm5lY3Rpb25QYXJhbXNFcnJvcihcbiAgICAgIGBDb3VsZCBub3QgcGFyc2UgdGhlIGNvbm5lY3Rpb24gc3RyaW5nYCxcbiAgICAgIGUsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghW1wicG9zdGdyZXNcIiwgXCJwb3N0Z3Jlc3FsXCJdLmluY2x1ZGVzKHBvc3RncmVzX3VyaS5kcml2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IENvbm5lY3Rpb25QYXJhbXNFcnJvcihcbiAgICAgIGBTdXBwbGllZCBEU04gaGFzIGludmFsaWQgZHJpdmVyOiAke3Bvc3RncmVzX3VyaS5kcml2ZXJ9LmAsXG4gICAgKTtcbiAgfVxuXG4gIC8vIE5vIGhvc3QgYnkgZGVmYXVsdCBtZWFucyBzb2NrZXQgY29ubmVjdGlvblxuICBjb25zdCBob3N0X3R5cGUgPSBwb3N0Z3Jlc191cmkuaG9zdFxuICAgID8gKGlzQWJzb2x1dGUocG9zdGdyZXNfdXJpLmhvc3QpID8gXCJzb2NrZXRcIiA6IFwidGNwXCIpXG4gICAgOiBcInNvY2tldFwiO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSBwb3N0Z3Jlc191cmkub3B0aW9uc1xuICAgID8gcGFyc2VPcHRpb25zQXJndW1lbnQocG9zdGdyZXNfdXJpLm9wdGlvbnMpXG4gICAgOiB7fTtcblxuICBsZXQgdGxzOiBUTFNPcHRpb25zIHwgdW5kZWZpbmVkO1xuICBzd2l0Y2ggKHBvc3RncmVzX3VyaS5zc2xtb2RlKSB7XG4gICAgY2FzZSB1bmRlZmluZWQ6IHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGlzYWJsZVwiOiB7XG4gICAgICB0bHMgPSB7IGVuYWJsZWQ6IGZhbHNlLCBlbmZvcmNlOiBmYWxzZSwgY2FDZXJ0aWZpY2F0ZXM6IFtdIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInByZWZlclwiOiB7XG4gICAgICB0bHMgPSB7IGVuYWJsZWQ6IHRydWUsIGVuZm9yY2U6IGZhbHNlLCBjYUNlcnRpZmljYXRlczogW10gfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwicmVxdWlyZVwiOlxuICAgIGNhc2UgXCJ2ZXJpZnktY2FcIjpcbiAgICBjYXNlIFwidmVyaWZ5LWZ1bGxcIjoge1xuICAgICAgdGxzID0geyBlbmFibGVkOiB0cnVlLCBlbmZvcmNlOiB0cnVlLCBjYUNlcnRpZmljYXRlczogW10gfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvblBhcmFtc0Vycm9yKFxuICAgICAgICBgU3VwcGxpZWQgRFNOIGhhcyBpbnZhbGlkIHNzbG1vZGUgJyR7cG9zdGdyZXNfdXJpLnNzbG1vZGV9J2AsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXBwbGljYXRpb25OYW1lOiBwb3N0Z3Jlc191cmkuYXBwbGljYXRpb25fbmFtZSxcbiAgICBkYXRhYmFzZTogcG9zdGdyZXNfdXJpLmRibmFtZSxcbiAgICBob3N0bmFtZTogcG9zdGdyZXNfdXJpLmhvc3QsXG4gICAgaG9zdF90eXBlLFxuICAgIG9wdGlvbnMsXG4gICAgcGFzc3dvcmQ6IHBvc3RncmVzX3VyaS5wYXNzd29yZCxcbiAgICBwb3J0OiBwb3N0Z3Jlc191cmkucG9ydCxcbiAgICB0bHMsXG4gICAgdXNlcjogcG9zdGdyZXNfdXJpLnVzZXIsXG4gIH07XG59XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUzpcbiAgJiBPbWl0PENsaWVudENvbmZpZ3VyYXRpb24sIFwiZGF0YWJhc2VcIiB8IFwidXNlclwiIHwgXCJob3N0bmFtZVwiPlxuICAmIHsgaG9zdDogc3RyaW5nOyBzb2NrZXQ6IHN0cmluZyB9ID0ge1xuICAgIGFwcGxpY2F0aW9uTmFtZTogXCJkZW5vX3Bvc3RncmVzXCIsXG4gICAgY29ubmVjdGlvbjoge1xuICAgICAgYXR0ZW1wdHM6IDEsXG4gICAgICBpbnRlcnZhbDogKHByZXZpb3VzX2ludGVydmFsKSA9PiBwcmV2aW91c19pbnRlcnZhbCArIDUwMCxcbiAgICB9LFxuICAgIGhvc3Q6IFwiMTI3LjAuMC4xXCIsXG4gICAgc29ja2V0OiBcIi90bXBcIixcbiAgICBob3N0X3R5cGU6IFwic29ja2V0XCIsXG4gICAgb3B0aW9uczoge30sXG4gICAgcG9ydDogNTQzMixcbiAgICB0bHM6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBlbmZvcmNlOiBmYWxzZSxcbiAgICAgIGNhQ2VydGlmaWNhdGVzOiBbXSxcbiAgICB9LFxuICB9O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFyYW1zKFxuICBwYXJhbXM6IHN0cmluZyB8IENsaWVudE9wdGlvbnMgPSB7fSxcbik6IENsaWVudENvbmZpZ3VyYXRpb24ge1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhcmFtcyA9IHBhcnNlT3B0aW9uc0Zyb21VcmkocGFyYW1zKTtcbiAgfVxuXG4gIGxldCBwZ0VudjogQ2xpZW50T3B0aW9ucyA9IHt9O1xuICBsZXQgaGFzX2Vudl9hY2Nlc3MgPSB0cnVlO1xuICB0cnkge1xuICAgIHBnRW52ID0gZ2V0UGdFbnYoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRGVuby5lcnJvcnMuUGVybWlzc2lvbkRlbmllZCkge1xuICAgICAgaGFzX2Vudl9hY2Nlc3MgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm92aWRlZF9ob3N0ID0gcGFyYW1zLmhvc3RuYW1lID8/IHBnRW52Lmhvc3RuYW1lO1xuXG4gIC8vIElmIGEgaG9zdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgY29ubmVjdGlvbiB0eXBlIGlzIFRDUFxuICBjb25zdCBob3N0X3R5cGUgPSBwYXJhbXMuaG9zdF90eXBlID8/XG4gICAgKHByb3ZpZGVkX2hvc3QgPyBcInRjcFwiIDogREVGQVVMVF9PUFRJT05TLmhvc3RfdHlwZSk7XG4gIGlmICghW1widGNwXCIsIFwic29ja2V0XCJdLmluY2x1ZGVzKGhvc3RfdHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgQ29ubmVjdGlvblBhcmFtc0Vycm9yKGBcIiR7aG9zdF90eXBlfVwiIGlzIG5vdCBhIHZhbGlkIGhvc3QgdHlwZWApO1xuICB9XG5cbiAgbGV0IGhvc3Q6IHN0cmluZztcbiAgaWYgKGhvc3RfdHlwZSA9PT0gXCJzb2NrZXRcIikge1xuICAgIGNvbnN0IHNvY2tldCA9IHByb3ZpZGVkX2hvc3QgPz8gREVGQVVMVF9PUFRJT05TLnNvY2tldDtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0Fic29sdXRlKHNvY2tldCkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkX2hvc3QgPSBuZXcgVVJMKHNvY2tldCwgRGVuby5tYWluTW9kdWxlKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgICAgICAgaWYgKHBhcnNlZF9ob3N0LnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgICAgICBob3N0ID0gZnJvbUZpbGVVcmwocGFyc2VkX2hvc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGhvc3QgaXMgbm90IGEgZmlsZSBwYXRoXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9zdCA9IHNvY2tldDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvblBhcmFtc0Vycm9yKFxuICAgICAgICBgQ291bGQgbm90IHBhcnNlIGhvc3QgXCIke3NvY2tldH1cImAsXG4gICAgICAgIGUsXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBob3N0ID0gcHJvdmlkZWRfaG9zdCA/PyBERUZBVUxUX09QVElPTlMuaG9zdDtcbiAgfVxuXG4gIGNvbnN0IHByb3ZpZGVkX29wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyA/PyBwZ0Vudi5vcHRpb25zO1xuXG4gIGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBpZiAocHJvdmlkZWRfb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcHJvdmlkZWRfb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9uc0FyZ3VtZW50KHByb3ZpZGVkX29wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gcHJvdmlkZWRfb3B0aW9ucztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGlmICghL15cXHcrJC8udGVzdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7a2V5fVwiIGtleSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudCBpcyBpbnZhbGlkYCk7XG4gICAgfVxuXG4gICAgb3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldLnJlcGxhY2VBbGwoXCIgXCIsIFwiXFxcXCBcIik7XG4gIH1cblxuICBsZXQgcG9ydDogbnVtYmVyO1xuICBpZiAocGFyYW1zLnBvcnQpIHtcbiAgICBwb3J0ID0gTnVtYmVyKHBhcmFtcy5wb3J0KTtcbiAgfSBlbHNlIGlmIChwZ0Vudi5wb3J0KSB7XG4gICAgcG9ydCA9IE51bWJlcihwZ0Vudi5wb3J0KTtcbiAgfSBlbHNlIHtcbiAgICBwb3J0ID0gREVGQVVMVF9PUFRJT05TLnBvcnQ7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihwb3J0KSB8fCBwb3J0ID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IENvbm5lY3Rpb25QYXJhbXNFcnJvcihcbiAgICAgIGBcIiR7cGFyYW1zLnBvcnQgPz8gcGdFbnYucG9ydH1cIiBpcyBub3QgYSB2YWxpZCBwb3J0IG51bWJlcmAsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChob3N0X3R5cGUgPT09IFwic29ja2V0XCIgJiYgcGFyYW1zPy50bHMpIHtcbiAgICB0aHJvdyBuZXcgQ29ubmVjdGlvblBhcmFtc0Vycm9yKFxuICAgICAgYE5vIFRMUyBvcHRpb25zIGFyZSBhbGxvd2VkIHdoZW4gaG9zdCB0eXBlIGlzIHNldCB0byBcInNvY2tldFwiYCxcbiAgICApO1xuICB9XG4gIGNvbnN0IHRsc19lbmFibGVkID0gISEocGFyYW1zPy50bHM/LmVuYWJsZWQgPz8gREVGQVVMVF9PUFRJT05TLnRscy5lbmFibGVkKTtcbiAgY29uc3QgdGxzX2VuZm9yY2VkID0gISEocGFyYW1zPy50bHM/LmVuZm9yY2UgPz8gREVGQVVMVF9PUFRJT05TLnRscy5lbmZvcmNlKTtcblxuICBpZiAoIXRsc19lbmFibGVkICYmIHRsc19lbmZvcmNlZCkge1xuICAgIHRocm93IG5ldyBDb25uZWN0aW9uUGFyYW1zRXJyb3IoXG4gICAgICBcIkNhbid0IGVuZm9yY2UgVExTIHdoZW4gY2xpZW50IGhhcyBUTFMgZW5jcnlwdGlvbiBpcyBkaXNhYmxlZFwiLFxuICAgICk7XG4gIH1cblxuICAvLyBUT0RPXG4gIC8vIFBlcmhhcHMgdXNlcm5hbWUgc2hvdWxkIGJlIHRha2VuIGZyb20gdGhlIFBDIHVzZXIgYXMgYSBkZWZhdWx0P1xuICBjb25zdCBjb25uZWN0aW9uX29wdGlvbnMgPSB7XG4gICAgYXBwbGljYXRpb25OYW1lOiBwYXJhbXMuYXBwbGljYXRpb25OYW1lID8/IHBnRW52LmFwcGxpY2F0aW9uTmFtZSA/P1xuICAgICAgREVGQVVMVF9PUFRJT05TLmFwcGxpY2F0aW9uTmFtZSxcbiAgICBjb25uZWN0aW9uOiB7XG4gICAgICBhdHRlbXB0czogcGFyYW1zPy5jb25uZWN0aW9uPy5hdHRlbXB0cyA/P1xuICAgICAgICBERUZBVUxUX09QVElPTlMuY29ubmVjdGlvbi5hdHRlbXB0cyxcbiAgICAgIGludGVydmFsOiBwYXJhbXM/LmNvbm5lY3Rpb24/LmludGVydmFsID8/XG4gICAgICAgIERFRkFVTFRfT1BUSU9OUy5jb25uZWN0aW9uLmludGVydmFsLFxuICAgIH0sXG4gICAgZGF0YWJhc2U6IHBhcmFtcy5kYXRhYmFzZSA/PyBwZ0Vudi5kYXRhYmFzZSxcbiAgICBob3N0bmFtZTogaG9zdCxcbiAgICBob3N0X3R5cGUsXG4gICAgb3B0aW9ucyxcbiAgICBwYXNzd29yZDogcGFyYW1zLnBhc3N3b3JkID8/IHBnRW52LnBhc3N3b3JkLFxuICAgIHBvcnQsXG4gICAgdGxzOiB7XG4gICAgICBlbmFibGVkOiB0bHNfZW5hYmxlZCxcbiAgICAgIGVuZm9yY2U6IHRsc19lbmZvcmNlZCxcbiAgICAgIGNhQ2VydGlmaWNhdGVzOiBwYXJhbXM/LnRscz8uY2FDZXJ0aWZpY2F0ZXMgPz8gW10sXG4gICAgfSxcbiAgICB1c2VyOiBwYXJhbXMudXNlciA/PyBwZ0Vudi51c2VyLFxuICB9O1xuXG4gIGFzc2VydFJlcXVpcmVkT3B0aW9ucyhcbiAgICBjb25uZWN0aW9uX29wdGlvbnMsXG4gICAgW1wiYXBwbGljYXRpb25OYW1lXCIsIFwiZGF0YWJhc2VcIiwgXCJob3N0bmFtZVwiLCBcImhvc3RfdHlwZVwiLCBcInBvcnRcIiwgXCJ1c2VyXCJdLFxuICAgIGhhc19lbnZfYWNjZXNzLFxuICApO1xuXG4gIHJldHVybiBjb25uZWN0aW9uX29wdGlvbnM7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxrQkFBa0IsUUFBUSxtQkFBbUIsQ0FBQztBQUN2RCxTQUFTLHFCQUFxQixRQUFRLG9CQUFvQixDQUFDO0FBQzNELFNBQVMsV0FBVyxFQUFFLFVBQVUsUUFBUSxZQUFZLENBQUM7QUFvQnJEOzs7OztDQUtDLEdBQ0QsU0FBUyxRQUFRLEdBQWtCO0lBQ2pDLE9BQU87UUFDTCxlQUFlLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO1FBQzFDLFFBQVEsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUM7UUFDcEMsUUFBUSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztRQUNoQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEdB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